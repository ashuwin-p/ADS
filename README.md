# UIT2402 Advanced Data Structures and Algorithms

Welcome to the repository for the UIT2402 Advanced Data Structures and Algorithms course! This repository contains the code examples and exercises to help you master advanced concepts in data structures and algorithms.

## üìÇ File List

- `dijkstra.py`
- `EX_1_Splay_Tree.py`
- `EX_3_BFS.py`
- `EX_3_DFS.py`
- `EX_3_Travelling_salesman_problem.py`
- `EX_4_closest_pair.py`
- `EX_4_merge_sort.py`
- `EX_5_huffman_coding.py`
- `EX_6_Kruskal.py`
- `EX_7_bellman_ford.py`
- `EX_7_binomial_coefficient.py`
- `EX_8_cycle_detection.py`
- `EX_8_Hamilton.py`
- `EX_8_Nqueens.py`
- `EX_8_Sum_of_subsets.py`
- `EX_9_max_flow.py`
- `EX_9_Stable_matching.py`
- `EX_10_knap_sack.py`
- `EX_11_knap_sack_approximation.py`
- `EX_12_parallel_merge_sort.py`
- `my_graph.py`
- `README.md`
- `warshall_floyd.py`

## üìú Description of Files

- **`dijkstra.py`**: Implementation of Dijkstra's algorithm for finding the shortest paths from a single source node to all other nodes in a weighted graph.

- **`EX_1_Splay_Tree.py`**: Implementation of splay tree operations including insertion, deletion, and splaying (self-adjusting binary search tree operations).

- **`EX_3_BFS.py`**: Breadth-First Search (BFS) algorithm for traversing or searching tree or graph data structures, starting from the root node and exploring all neighbors at the present depth prior to moving on to nodes at the next depth level.

- **`EX_3_DFS.py`**: Depth-First Search (DFS) algorithm for traversing or searching tree or graph data structures, starting from the root and exploring as far as possible along each branch before backtracking.

- **`EX_3_Travelling_salesman_problem.py`**: Solutions for the Travelling Salesman Problem (TSP), which aims to find the shortest possible route that visits each city exactly once and returns to the origin city.

- **`EX_4_closest_pair.py`**: Algorithm to find the closest pair of points in a plane, which can be solved in O(n log n) time using a divide-and-conquer approach.

- **`EX_4_merge_sort.py`**: Implementation of the merge sort algorithm, an efficient, stable, comparison-based, divide-and-conquer sorting algorithm.

- **`EX_5_huffman_coding.py`**: Implementation of Huffman coding, a lossless data compression algorithm that assigns variable-length codes to input characters, with shorter codes assigned to more frequent characters.

- **`EX_6_Kruskal.py`**: Kruskal's algorithm for finding the Minimum Spanning Tree (MST) of a graph, which finds a subset of the edges that connects all vertices in the graph without any cycles and with the minimum possible total edge weight.

- **`EX_7_bellman_ford.py`**: Bellman-Ford algorithm for finding the shortest paths from a single source vertex to all other vertices in a weighted graph, which can handle graphs with negative weight edges.

- **`EX_7_binomial_coefficient.py`**: Calculation of binomial coefficients, which are the coefficients in the binomial theorem and represent the number of ways to choose k elements from a set of n elements.

- **`EX_8_cycle_detection.py`**: Algorithms for detecting cycles in a graph, which can determine if a graph contains a cycle (a path of edges and vertices wherein a vertex is reachable from itself).

- **`EX_8_Hamilton.py`**: Solution for the Hamiltonian path problem, which determines whether a path exists in a graph that visits each vertex exactly once.

- **`EX_8_Nqueens.py`**: Solution for the N-Queens problem, which aims to place N chess queens on an N√óN chessboard so that no two queens threaten each other.

- **`EX_8_Sum_of_subsets.py`**: Solution for the sum of subsets problem, which finds subsets of a given set whose sums are equal to a given target value.

- **`EX_9_max_flow.py`**: Implementation of algorithms for the maximum flow problem, which finds the maximum flow in a flow network.

- **`EX_9_Stable_matching.py`**: Implementation of the stable matching algorithm (Gale-Shapley algorithm), which finds a stable matching between two equally sized sets of elements.

- **`EX_10_knap_sack.py`**: Exact solution for the knapsack problem using dynamic programming, which aims to maximize the total value of items that can be included in a knapsack of a given capacity.

- **`EX_11_knap_sack_approximation.py`**: Approximation algorithm for the knapsack problem, providing a near-optimal solution in cases where an exact solution is computationally expensive.

- **`EX_12_parallel_merge_sort.py`**: Implementation of the parallel merge sort algorithm, which sorts data by dividing the list into sublists, sorting them in parallel, and then merging them.

- **`my_graph.py`**: Various graph-related algorithms and utilities, including implementations of common graph algorithms.

- **`warshall_floyd.py`**: Implementation of the Warshall-Floyd algorithm (also known as the Floyd-Warshall algorithm), which finds shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles).

## üöÄ How to Run

1. **Clone this repository to your local machine:**
   ```bash
   git clone https://github.com/ashuwin-p/ADS.git

2. **Navigate to the directory:**
   ```bash
   cd ADS
3. **Run the desired Python script:**
    ```bash
    python EX_1_Splay_Tree.py

## ü§ù Contributing
Contributions are welcome! Please fork the repository and submit a pull request for any improvements or bug fixes.